package org.javalaboratories.healthagents.configuration;

import org.javalaboratories.core.Maybe;
import org.javalaboratories.healthagents.configuration.ServiceConfiguration.RsaSecurity;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.web.filter.GenericFilterBean;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.*;

/**
 * Filter to introduce RSA security feature to REST APIs.
 * <p>
 * The security identifier can either be static or dynamic, calculated by the
 * the server. Currently, the dynamic aspect has not been implemented yet at
 * this time.However, the request will be rejected with a <code>403 HTTP</code>
 * status code if the supplied <code>X-Header-RSA-Secure-ID</code> header is
 * incorrect.
 */
public final class RsaSecureIdAuthenticationFilter extends GenericFilterBean {

    private static final String X_HEADER_RSA_SECURE_ID = "X-Header-RSA-Secure-ID";
    private static final Logger logger = LoggerFactory.getLogger(RsaSecureIdAuthenticationFilter.class);

    private final RsaSecurity security;

    /**
     * Constructs this filter with a <code>RsaSecurity</code> object.
     * @param security RsaSecurity object.
     */
    public RsaSecureIdAuthenticationFilter(final RsaSecurity security) {
        this.security = Objects.requireNonNull(security,"Requires RSA security object in order to proceed");
    }

    /**
     * {@inheritDoc}
     *
     * Validates X-Header-RSA-Secure-ID header. If the header is not present or the
     * <code>Secure-ID</code> is incorrect then the request is rejected with
     * <code>403 HTTP</code> status code. It will also report the Client IP address(es)
     * in the logs, if they are available.
     */
    public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain)
            throws IOException, ServletException {
        this.doFilter((HttpServletRequest)request, (HttpServletResponse)response, chain);
    }

    private void doFilter(final HttpServletRequest request, final HttpServletResponse response, final FilterChain chain)
            throws IOException, ServletException {
        String secretId = request.getHeader(X_HEADER_RSA_SECURE_ID);
        secretId = secretId == null ? "" : secretId;
        if (security.isAutoGenerated()) {
            logger.debug("RSA secure identifier with `auto-generate` enabled but not supported");
            response.sendError(HttpStatus.FORBIDDEN.value(), HttpStatus.FORBIDDEN.getReasonPhrase());
        } else {
            if (!secretId.equals(security.getSecurityId())) {
                logger.error("RSA secure identifier invalid, client details are as follows: \n{}",
                    getClientHosts(request)
                        .map(m -> m.keySet().stream()
                            .map(k -> String.format("    --> %s=%s\n",k,m.get(k)))
                            .reduce("", (a,b) -> a + b))
                        .fold("    --> Client Host(s) Unavailable\n",s -> s));
                response.sendError(HttpStatus.FORBIDDEN.value(), HttpStatus.FORBIDDEN.getReasonPhrase());
            } else {
                logger.debug("RSA secure identifier received and verified successfully");
                chain.doFilter(request, response);
            }
        }
    }

    private Maybe<Map<String,String>> getClientHosts(final HttpServletRequest request) {
        List<String> headers = Arrays.asList (
            "HTTP_CLIENT_IP",
            "HTTP_X_FORWARDED_FOR",    // 167.128.91.200; 99.128.100.1
            "HTTP_X_FORWARDED",
            "HTTP_X_CLUSTER_CLIENT_IP",
            "HTTP_FORWARDED_FOR",
            "HTTP_FORWARDED",
            "REMOTE_ADDR"
        );
        Maybe<Map<String,String>> result = Collections.list(request.getHeaderNames()).stream()
                .map(String::toUpperCase)
                .filter(headers::contains)
                .reduce(Maybe.of(new HashMap<>()),
                        (m,s) -> Maybe.of(m.fold(new HashMap<>(),
                        map -> {map.put(s,request.getHeader(s));return map;})),
                        (m,r) -> r);
        return result.fold(0,Map::size) == 0 ? Maybe.empty() : result;
    }
}
